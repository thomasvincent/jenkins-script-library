#!/usr/bin/env groovy

/*
 * MIT License
 *
 * Copyright (c) 2023-2025 Thomas Vincent
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package com.github.thomasvincent.jenkinsscripts.scripts

import com.github.thomasvincent.jenkinsscripts.util.ValidationUtils
import com.github.thomasvincent.jenkinsscripts.util.ErrorHandler
import jenkins.model.Jenkins
import hudson.model.Item
import hudson.model.Run
import hudson.model.User
import jenkins.security.s2m.AdminWhitelistRule
import org.jenkinsci.plugins.workflow.job.WorkflowJob
import jenkins.model.JenkinsLocationConfiguration
import jenkins.security.ApiTokenProperty
import hudson.util.Secret
import groovy.cli.commons.CliBuilder
import groovy.json.JsonOutput
import groovy.json.JsonSlurper

import java.util.logging.Level
import java.util.logging.Logger
import java.util.jar.JarFile
import java.text.SimpleDateFormat
import java.util.regex.Pattern

/**
 * Scans Jenkins for security vulnerabilities and misconfigurations.
 * 
 * '''Usage:'''
 * ```groovy
 * # Run basic security scan
 * ./SecurityVulnerabilityScan.groovy
 * 
 * # Scan only specific areas
 * ./SecurityVulnerabilityScan.groovy --areas plugins,credentials,scripts
 * 
 * # Set minimum severity level
 * ./SecurityVulnerabilityScan.groovy --severity medium
 * 
 * # Include detailed recommendations
 * ./SecurityVulnerabilityScan.groovy --detailed
 * 
 * # Output in JSON format
 * ./SecurityVulnerabilityScan.groovy --json
 * 
 * # Generate compliance report
 * ./SecurityVulnerabilityScan.groovy --compliance cis,owasp
 * ```
 * 
 * @author Thomas Vincent
 * @since 1.1.0
 */

/**
 * Logger for this script.
 */
private static final Logger LOGGER = Logger.getLogger("SecurityVulnerabilityScan.groovy")

/**
 * Creates a command-line argument parser for the script.
 * 
 * <p>Configures the available command-line options that can be used
 * when running this script.</p>
 */
def cli = new CliBuilder(usage: 'groovy SecurityVulnerabilityScan [options]',
                        header: 'Options:')
cli.with {
    h(longOpt: 'help', 'Show usage information')
    j(longOpt: 'json', 'Output in JSON format')
    a(longOpt: 'areas', args: 1, argName: 'list', 'Areas to scan (plugins,credentials,permissions,scripts,agents,jvm,configuration)')
    s(longOpt: 'severity', args: 1, argName: 'level', 'Minimum severity level to report (critical,high,medium,low,info)')
    d(longOpt: 'detailed', 'Include detailed recommendations')
    c(longOpt: 'compliance', args: 1, argName: 'standards', 'Generate compliance report (cis,owasp,nist)')
    o(longOpt: 'output', args: 1, argName: 'file', 'Write results to file')
}

/**
 * Parse the provided command-line arguments.
 * 
 * <p>If parsing fails, the script will exit.</p>
 */
def options = cli.parse(args)
if (!options) {
    return
}

/**
 * Display help information if requested.
 * 
 * <p>If the help option is specified, shows usage information and exits.</p>
 */
if (options.h) {
    cli.usage()
    return
}

/**
 * Parse parameters with defaults.
 */
def areasToScan = options.areas ? options.areas.split(',').collect { it.trim() } : 
    ['plugins', 'credentials', 'permissions', 'scripts', 'agents', 'jvm', 'configuration']
def minSeverity = options.severity ?: 'medium'
def includeDetailed = options.detailed ?: false
def complianceStandards = options.compliance ? options.compliance.split(',').collect { it.trim() } : []
def outputFile = options.output

// Severity level mapping for filtering
def severityLevels = ['critical': 5, 'high': 4, 'medium': 3, 'low': 2, 'info': 1]
def minSeverityLevel = severityLevels[minSeverity.toLowerCase()] ?: 3

/**
 * Get the current Jenkins instance.
 */
def jenkins = Jenkins.get()

/**
 * Run the security vulnerability scan.
 */
def scanResults = runSecurityScan(jenkins, areasToScan, minSeverityLevel, includeDetailed, complianceStandards)

/**
 * Format and output the results.
 */
if (options.json) {
    // Output in JSON format
    def jsonOutput = JsonOutput.prettyPrint(JsonOutput.toJson(scanResults))
    
    if (outputFile) {
        new File(outputFile).text = jsonOutput
        println "Results written to ${outputFile}"
    } else {
        println jsonOutput
    }
} else {
    // Output in human-readable format
    def formattedOutput = formatScanResults(scanResults, includeDetailed)
    
    if (outputFile) {
        new File(outputFile).text = formattedOutput
        println "Results written to ${outputFile}"
    } else {
        println formattedOutput
    }
}

/**
 * Runs the security vulnerability scan.
 * 
 * @param jenkins The Jenkins instance
 * @param areasToScan List of areas to scan
 * @param minSeverityLevel Minimum severity level to report
 * @param includeDetailed Whether to include detailed recommendations
 * @param complianceStandards List of compliance standards to check against
 * @return Map with scan results
 */
def runSecurityScan(Jenkins jenkins, List<String> areasToScan, int minSeverityLevel, 
                   boolean includeDetailed, List<String> complianceStandards) {
    def startTime = System.currentTimeMillis()
    def findings = []
    def summary = [:]
    def complianceResults = [:]
    
    if ('plugins' in areasToScan) {
        findings.addAll(scanPlugins(jenkins, minSeverityLevel))
    }
    
    if ('credentials' in areasToScan) {
        findings.addAll(scanCredentials(jenkins, minSeverityLevel))
    }
    
    if ('permissions' in areasToScan) {
        findings.addAll(scanPermissions(jenkins, minSeverityLevel))
    }
    
    if ('scripts' in areasToScan) {
        findings.addAll(scanScripts(jenkins, minSeverityLevel))
    }
    
    if ('agents' in areasToScan) {
        findings.addAll(scanAgents(jenkins, minSeverityLevel))
    }
    
    if ('jvm' in areasToScan) {
        findings.addAll(scanJvmSecurity(minSeverityLevel))
    }
    
    if ('configuration' in areasToScan) {
        findings.addAll(scanJenkinsConfiguration(jenkins, minSeverityLevel))
    }
    
    // Generate summary statistics
    def severityCounts = [critical: 0, high: 0, medium: 0, low: 0, info: 0]
    def areaCounts = areasToScan.collectEntries { [(it): 0] }
    
    findings.each { finding ->
        severityCounts[finding.severity]++
        areaCounts[finding.area]++
    }
    
    summary = [
        scanTime: new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()),
        duration: System.currentTimeMillis() - startTime,
        totalFindings: findings.size(),
        severityCounts: severityCounts,
        areaCounts: areaCounts,
        jenkinsVersion: jenkins.version,
        scannedAreas: areasToScan
    ]
    
    // Generate compliance results if requested
    if (complianceStandards) {
        complianceResults = generateComplianceReport(findings, complianceStandards)
    }
    
    return [
        summary: summary,
        findings: findings,
        compliance: complianceResults
    ]
}

/**
 * Scans plugins for vulnerabilities.
 * 
 * @param jenkins The Jenkins instance
 * @param minSeverityLevel Minimum severity level to report
 * @return List of finding maps
 */
def scanPlugins(Jenkins jenkins, int minSeverityLevel) {
    return ErrorHandler.withErrorHandling("scanning plugins", {
        def findings = []
        def plugins = jenkins.pluginManager.plugins
        
        // Check for outdated plugins
        plugins.each { plugin ->
            if (plugin.hasUpdate()) {
                def severity = 'medium'
                if (plugin.isActive() && plugin.isEnabled() && plugin.getShortName() in ['credentials', 'ssh-credentials', 'script-security', 'matrix-auth', 'role-strategy']) {
                    severity = 'high'
                }
                
                if (severityValue(severity) >= minSeverityLevel) {
                    findings.add([
                        id: "PLUGIN-001",
                        severity: severity,
                        area: "plugins",
                        title: "Outdated Plugin: ${plugin.getDisplayName()}",
                        description: "Plugin ${plugin.getDisplayName()} (${plugin.getShortName()}) version ${plugin.getVersion()} has an update available.",
                        recommendation: "Update the plugin to the latest version to address security vulnerabilities.",
                        evidence: [
                            currentVersion: plugin.getVersion(),
                            latestVersion: plugin.getUpdateInfo()?.version ?: "unknown",
                            plugin: plugin.getShortName()
                        ]
                    ])
                }
            }
        }
        
        // Check for known vulnerable plugins (simplified example - in a real implementation, this would check against a vulnerability database)
        def knownVulnerablePlugins = [
            [name: "pipeline-model-definition", vulnerableBelow: "1.5.0", severity: "high", cve: "CVE-2020-2109"],
            [name: "git", vulnerableBelow: "4.0.0", severity: "high", cve: "CVE-2019-10393"],
            [name: "subversion", vulnerableBelow: "2.12.1", severity: "high", cve: "CVE-2019-10346"]
        ]
        
        plugins.each { plugin ->
            def vulnerabilityInfo = knownVulnerablePlugins.find { it.name == plugin.getShortName() }
            if (vulnerabilityInfo) {
                def currentVersion = plugin.getVersion()
                def vulnerableBelow = vulnerabilityInfo.vulnerableBelow
                
                if (isVersionLessThan(currentVersion, vulnerableBelow) && 
                    severityValue(vulnerabilityInfo.severity) >= minSeverityLevel) {
                    findings.add([
                        id: "PLUGIN-002",
                        severity: vulnerabilityInfo.severity,
                        area: "plugins",
                        title: "Vulnerable Plugin: ${plugin.getDisplayName()}",
                        description: "Plugin ${plugin.getDisplayName()} (${plugin.getShortName()}) version ${plugin.getVersion()} has known security vulnerabilities.",
                        recommendation: "Update the plugin to version ${vulnerableBelow} or later to address the security vulnerability.",
                        evidence: [
                            currentVersion: currentVersion,
                            vulnerableBelow: vulnerableBelow,
                            plugin: plugin.getShortName(),
                            cve: vulnerabilityInfo.cve
                        ]
                    ])
                }
            }
        }
        
        // Check for disabled security plugins
        def securityPlugins = [
            'matrix-auth', 'role-strategy', 'credentials', 'script-security',
            'job-restrictions', 'authorize-project', 'antisamy-markup-formatter'
        ]
        
        securityPlugins.each { pluginName ->
            def plugin = jenkins.pluginManager.getPlugin(pluginName)
            if (plugin && (!plugin.isActive() || !plugin.isEnabled())) {
                if (severityValue('high') >= minSeverityLevel) {
                    findings.add([
                        id: "PLUGIN-003",
                        severity: "high",
                        area: "plugins",
                        title: "Security Plugin Disabled: ${pluginName}",
                        description: "Security plugin ${pluginName} is installed but not active or disabled.",
                        recommendation: "Enable the security plugin to improve Jenkins security posture.",
                        evidence: [
                            plugin: pluginName,
                            active: plugin.isActive(),
                            enabled: plugin.isEnabled()
                        ]
                    ])
                }
            }
        }
        
        return findings
    }, LOGGER, [])
}

/**
 * Scans credentials for vulnerabilities.
 * 
 * @param jenkins The Jenkins instance
 * @param minSeverityLevel Minimum severity level to report
 * @return List of finding maps
 */
def scanCredentials(Jenkins jenkins, int minSeverityLevel) {
    return ErrorHandler.withErrorHandling("scanning credentials", {
        def findings = []
        
        // Check if credentials plugin is installed
        if (jenkins.pluginManager.getPlugin('credentials') == null) {
            if (severityValue('high') >= minSeverityLevel) {
                findings.add([
                    id: "CRED-001",
                    severity: "high",
                    area: "credentials",
                    title: "Credentials Plugin Not Installed",
                    description: "The Credentials Plugin is not installed, which is required for secure credential management.",
                    recommendation: "Install the Credentials Plugin to securely manage sensitive credentials.",
                    evidence: [
                        credentialsPluginInstalled: false
                    ]
                ])
            }
            return findings
        }
        
        // Check for global permissions to credentials
        try {
            def credentialsStore = com.cloudbees.plugins.credentials.CredentialsProvider.lookupStores(jenkins).iterator().next()
            def allCreds = com.cloudbees.plugins.credentials.CredentialsProvider.lookupCredentials(
                com.cloudbees.plugins.credentials.common.StandardCredentials.class,
                jenkins,
                null,
                Collections.emptyList()
            )
            
            if (allCreds.size() > 0) {
                // Check if anonymous has access to credentials
                def anonPermissions = jenkins.authorizationStrategy.getACL(jenkins).getPermission(
                    new com.cloudbees.plugins.credentials.CredentialsProvider.ViewCredentialsAction(jenkins),
                    jenkins.ANONYMOUS
                )
                
                if (anonPermissions) {
                    if (severityValue('critical') >= minSeverityLevel) {
                        findings.add([
                            id: "CRED-002",
                            severity: "critical",
                            area: "credentials",
                            title: "Anonymous Access to Credentials",
                            description: "Anonymous users have permission to view credentials.",
                            recommendation: "Reconfigure permissions to ensure only authorized users can view credentials.",
                            evidence: [
                                anonymousAccess: true,
                                credentialsCount: allCreds.size()
                            ]
                        ])
                    }
                }
            }
        } catch (Exception ignored) {
            // Credential checks may fail if certain plugins aren't available
        }
        
        // Check for plain text credentials
        try {
            def credentialsWithPlaintext = []
            
            def allCreds = com.cloudbees.plugins.credentials.CredentialsProvider.lookupCredentials(
                Object.class,
                jenkins,
                null,
                Collections.emptyList()
            )
            
            allCreds.each { cred ->
                if (cred instanceof com.cloudbees.plugins.credentials.common.StandardCredentials) {
                    def credId = cred.id
                    def credName = (cred.hasProperty('description') && cred.description) ? cred.description : credId
                    
                    // Check specifically for plaintext credentials
                    if (cred instanceof org.jenkinsci.plugins.plaincredentials.impl.StringCredentialsImpl ||
                        (cred.class.name.contains('StringCredentials') && !cred.class.name.contains('Secret'))) {
                        credentialsWithPlaintext << [id: credId, name: credName]
                    }
                }
            }
            
            if (credentialsWithPlaintext && severityValue('high') >= minSeverityLevel) {
                findings.add([
                    id: "CRED-003",
                    severity: "high",
                    area: "credentials",
                    title: "Plaintext Credentials Found",
                    description: "Jenkins is storing credentials that appear to be using plaintext storage.",
                    recommendation: "Replace plaintext credentials with secret text or other secure credential types.",
                    evidence: [
                        plainTextCredentials: credentialsWithPlaintext.size(),
                        examples: credentialsWithPlaintext.take(3)
                    ]
                ])
            }
        } catch (Exception ignored) {
            // Credential checks may fail if certain plugins aren't available
        }
        
        return findings
    }, LOGGER, [])
}

/**
 * Scans permission configurations for vulnerabilities.
 * 
 * @param jenkins The Jenkins instance
 * @param minSeverityLevel Minimum severity level to report
 * @return List of finding maps
 */
def scanPermissions(Jenkins jenkins, int minSeverityLevel) {
    return ErrorHandler.withErrorHandling("scanning permissions", {
        def findings = []
        
        // Check if security is enabled
        if (!jenkins.isUseSecurity()) {
            if (severityValue('critical') >= minSeverityLevel) {
                findings.add([
                    id: "PERM-001",
                    severity: "critical",
                    area: "permissions",
                    title: "Security Not Enabled",
                    description: "Jenkins security is not enabled, allowing anyone full access to the instance.",
                    recommendation: "Enable Jenkins security immediately with appropriate authentication and authorization.",
                    evidence: [
                        securityEnabled: false
                    ]
                ])
            }
            return findings
        }
        
        // Check anonymous permissions
        def anonPermissions = []
        def authStrategy = jenkins.getAuthorizationStrategy()
        
        if (authStrategy.class.name.contains('GlobalMatrixAuthorizationStrategy') ||
            authStrategy.class.name.contains('ProjectMatrixAuthorizationStrategy')) {
            def anonAuth = authStrategy.getACL(jenkins).getGrantedPermissionEntries(jenkins.ANONYMOUS.id)
            anonPermissions = anonAuth.collect { it.toString() }
        }
        
        def adminPermissions = [
            'hudson.model.Hudson.Administer',
            'hudson.model.Computer.Configure',
            'hudson.model.Computer.Delete',
            'hudson.model.Hudson.ConfigureUpdateCenter',
            'com.cloudbees.plugins.credentials.CredentialsProvider.Update',
            'hudson.model.Computer.Create',
            'hudson.model.Run.Delete',
            'hudson.model.Hudson.UploadPlugins'
        ]
        
        def unauthorizedAnonPermissions = adminPermissions.findAll { it in anonPermissions }
        
        if (unauthorizedAnonPermissions) {
            if (severityValue('critical') >= minSeverityLevel) {
                findings.add([
                    id: "PERM-002",
                    severity: "critical",
                    area: "permissions",
                    title: "Anonymous Admin Permissions",
                    description: "Anonymous users have administrative permissions: ${unauthorizedAnonPermissions.join(', ')}",
                    recommendation: "Remove administrative permissions from anonymous users immediately.",
                    evidence: [
                        permissions: unauthorizedAnonPermissions
                    ]
                ])
            }
        } else if (anonPermissions && !anonPermissions.every { it == 'hudson.model.Hudson.Read' }) {
            // Some permissions beyond read-only
            if (severityValue('high') >= minSeverityLevel) {
                findings.add([
                    id: "PERM-003",
                    severity: "high",
                    area: "permissions",
                    title: "Excessive Anonymous Permissions",
                    description: "Anonymous users have more than read-only permissions: ${anonPermissions.join(', ')}",
                    recommendation: "Limit anonymous permissions to read-only or completely disable anonymous access.",
                    evidence: [
                        permissions: anonPermissions
                    ]
                ])
            }
        }
        
        // Check if unsecured api tokens are enabled
        try {
            def jenkinsApiToken = ApiTokenProperty.DescriptorImpl.get()
            if (jenkinsApiToken?.isTokenGenerationOnCreationEnabled() || jenkinsApiToken?.isCreationOfLegacyTokenEnabled()) {
                if (severityValue('high') >= minSeverityLevel) {
                    findings.add([
                        id: "PERM-004",
                        severity: "high",
                        area: "permissions",
                        title: "Insecure API Token Configuration",
                        description: "Jenkins is configured to automatically generate API tokens or allow legacy tokens.",
                        recommendation: "Disable automatic token generation and legacy tokens. Use only tokenized credentials with appropriate scope.",
                        evidence: [
                            tokenGenerationOnCreation: jenkinsApiToken?.isTokenGenerationOnCreationEnabled(),
                            legacyTokensEnabled: jenkinsApiToken?.isCreationOfLegacyTokenEnabled()
                        ]
                    ])
                }
            }
        } catch (Exception ignored) {
            // API token check may fail on older Jenkins versions
        }
        
        // Check for users with sensitive permissions
        def users = User.getAll()
        def usersWithAdminPerms = []
        
        users.each { user ->
            if (user.id == 'anonymous') return
            
            def hasAdmin = false
            try {
                hasAdmin = jenkins.getAuthorizationStrategy().getACL(jenkins).hasPermission(
                    user.impersonate(),
                    jenkins.ADMINISTER
                )
            } catch (Exception ignored) {}
            
            if (hasAdmin) {
                usersWithAdminPerms << user.id
            }
        }
        
        if (usersWithAdminPerms.size() > 3) {
            if (severityValue('medium') >= minSeverityLevel) {
                findings.add([
                    id: "PERM-005",
                    severity: "medium",
                    area: "permissions",
                    title: "Excessive Admin Users",
                    description: "There are ${usersWithAdminPerms.size()} users with administrative permissions.",
                    recommendation: "Reduce the number of administrator users and implement the principle of least privilege.",
                    evidence: [
                        adminUsers: usersWithAdminPerms
                    ]
                ])
            }
        }
        
        return findings
    }, LOGGER, [])
}

/**
 * Scans scripts and job configurations for vulnerabilities.
 * 
 * @param jenkins The Jenkins instance
 * @param minSeverityLevel Minimum severity level to report
 * @return List of finding maps
 */
def scanScripts(Jenkins jenkins, int minSeverityLevel) {
    return ErrorHandler.withErrorHandling("scanning scripts", {
        def findings = []
        
        // Check script security settings
        def scriptSecurity = jenkins.getExtensionList(jenkins.security.s2m.MasterKillSwitchConfiguration.class).get(0)
        if (scriptSecurity && !scriptSecurity.getMasterKillSwitch()) {
            def adminWhitelistRule = jenkins.getExtensionList(AdminWhitelistRule.class).get(0)
            if (!adminWhitelistRule.getMasterKillSwitch()) {
                // Script security is properly configured
            } else {
                if (severityValue('high') >= minSeverityLevel) {
                    findings.add([
                        id: "SCRIPT-001",
                        severity: "high",
                        area: "scripts",
                        title: "Agent to Controller Security Disabled",
                        description: "The agent-to-controller security system is disabled, allowing agents to send malicious commands to the controller.",
                        recommendation: "Enable agent-to-controller access control in security settings.",
                        evidence: [
                            masterKillSwitch: adminWhitelistRule.getMasterKillSwitch()
                        ]
                    ])
                }
            }
        } else {
            if (severityValue('critical') >= minSeverityLevel) {
                findings.add([
                    id: "SCRIPT-002",
                    severity: "critical",
                    area: "scripts",
                    title: "Agent to Controller Protection Globally Disabled",
                    description: "The agent-to-controller protection is globally disabled, allowing agents to send malicious commands to the controller.",
                    recommendation: "Enable agent-to-controller protection immediately in security settings.",
                    evidence: [
                        masterKillSwitch: scriptSecurity ? scriptSecurity.getMasterKillSwitch() : true
                    ]
                ])
            }
        }
        
        // Check for pipeline scripts with potential security issues
        def pipelineJobs = jenkins.getAllItems(WorkflowJob.class)
        def unsafePipelinePatterns = [
            [pattern: ~/(?i)(curl|wget|http:\/\/|https:\/\/)[^\s]*\|\s*(sh|bash)/, severity: "high", description: "Piping remote content to shell"],
            [pattern: ~/(?i)(rm|mv|cp)\s+(-rf|-r|-f)\s+\//, severity: "critical", description: "Dangerous file operations on root directory"],
            [pattern: ~/(?i)(chmod)\s+777/, severity: "high", description: "Setting overly permissive file permissions"],
            [pattern: ~/\.getSecret\(/, severity: "medium", description: "Potential credential exposure in script"],
            [pattern: ~/(?i)(eval|system|exec)\s*\(/, severity: "high", description: "Using potentially dangerous code execution functions"]
        ]
        
        def scriptsWithIssues = []
        
        pipelineJobs.each { job ->
            try {
                def scriptText = job.definition?.script ?: ""
                if (scriptText) {
                    unsafePipelinePatterns.each { pattern ->
                        def matcher = scriptText =~ pattern.pattern
                        if (matcher.find() && severityValue(pattern.severity) >= minSeverityLevel) {
                            def lineNumber = 0
                            def lines = scriptText.split("\n")
                            for (int i = 0; i < lines.size(); i++) {
                                if (lines[i] =~ pattern.pattern) {
                                    lineNumber = i + 1
                                    break
                                }
                            }
                            
                            scriptsWithIssues << [
                                job: job.fullName,
                                pattern: pattern.description,
                                severity: pattern.severity,
                                lineNumber: lineNumber
                            ]
                        }
                    }
                }
            } catch (Exception ignored) {
                // Job may not have a script definition
            }
        }
        
        if (scriptsWithIssues) {
            // Group by severity
            def groupedIssues = scriptsWithIssues.groupBy { it.severity }
            
            groupedIssues.each { severity, issues ->
                if (severityValue(severity) >= minSeverityLevel) {
                    findings.add([
                        id: "SCRIPT-003",
                        severity: severity,
                        area: "scripts",
                        title: "Potentially Unsafe Pipeline Scripts",
                        description: "Found ${issues.size()} pipeline scripts with potentially unsafe patterns (${severity} severity).",
                        recommendation: "Review and secure the identified pipeline scripts to prevent security vulnerabilities.",
                        evidence: [
                            issuesCount: issues.size(),
                            examples: issues.take(5)
                        ]
                    ])
                }
            }
        }
        
        // Check for approval of unsafe scripts
        try {
            def scriptApproval = org.jenkinsci.plugins.scriptsecurity.scripts.ScriptApproval.get()
            def approvedSignatures = scriptApproval.approvedSignatures
            
            def dangerousSignatures = approvedSignatures.findAll { signature ->
                signature.contains("java.io.File") ||
                signature.contains("jenkins.model.Jenkins") ||
                signature.contains("ProcessBuilder") ||
                signature.contains("java.lang.Runtime") ||
                signature.contains("exec") ||
                signature.contains("setExecutable") ||
                signature.contains("hudson.util.Secret")
            }
            
            if (dangerousSignatures && severityValue('high') >= minSeverityLevel) {
                findings.add([
                    id: "SCRIPT-004",
                    severity: "high",
                    area: "scripts",
                    title: "Dangerous Script Signatures Approved",
                    description: "Found ${dangerousSignatures.size()} potentially dangerous approved script signatures.",
                    recommendation: "Review and revoke approval for potentially dangerous script signatures.",
                    evidence: [
                        count: dangerousSignatures.size(),
                        examples: dangerousSignatures.take(5)
                    ]
                ])
            }
        } catch (Exception ignored) {
            // Script approval API may not be available
        }
        
        return findings
    }, LOGGER, [])
}

/**
 * Scans agent configurations for vulnerabilities.
 * 
 * @param jenkins The Jenkins instance
 * @param minSeverityLevel Minimum severity level to report
 * @return List of finding maps
 */
def scanAgents(Jenkins jenkins, int minSeverityLevel) {
    return ErrorHandler.withErrorHandling("scanning agents", {
        def findings = []
        
        // Check JNLP agent protocols
        def agentProtocols = jenkins.getAgentProtocols()
        def insecureProtocols = agentProtocols.findAll { it.startsWith("JNLP") && !it.endsWith("4") }
        
        if (insecureProtocols && severityValue('high') >= minSeverityLevel) {
            findings.add([
                id: "AGENT-001",
                severity: "high",
                area: "agents",
                title: "Insecure Agent Protocols Enabled",
                description: "Insecure agent protocols are enabled: ${insecureProtocols.join(', ')}",
                recommendation: "Disable insecure agent protocols and use only JNLP4.",
                evidence: [
                    protocols: insecureProtocols
                ]
            ])
        }
        
        // Check agent launch method
        def insecureLaunchMethods = []
        jenkins.computers.each { computer ->
            if (computer.name == "master") return
            
            try {
                def launcher = computer.launcher
                def launcherClass = launcher.class.name
                
                if (launcherClass.contains("CommandLauncher")) {
                    insecureLaunchMethods << [computer: computer.name, method: "Command Launcher"]
                } else if (launcherClass.contains("JNLPLauncher") && !jenkins.isUseSecurity()) {
                    insecureLaunchMethods << [computer: computer.name, method: "JNLP with Security Disabled"]
                }
            } catch (Exception ignored) {
                // Computer may not have a launcher
            }
        }
        
        if (insecureLaunchMethods && severityValue('medium') >= minSeverityLevel) {
            findings.add([
                id: "AGENT-002",
                severity: "medium",
                area: "agents",
                title: "Insecure Agent Launch Methods",
                description: "Found ${insecureLaunchMethods.size()} agents using potentially insecure launch methods.",
                recommendation: "Use SSH or secured JNLP agents instead of command launchers.",
                evidence: [
                    agents: insecureLaunchMethods
                ]
            ])
        }
        
        // Check agent permissions
        def permissiveAgentRestrictions = []
        
        // Check for agent restrictions plugin
        if (jenkins.pluginManager.getPlugin("job-restrictions")) {
            try {
                def restrictionsProperty = hudson.plugins.job_restrictions.nodes.JobRestrictionProperty.all()
                
                jenkins.computers.each { computer ->
                    if (computer.name == "master") return
                    
                    def node = computer.node
                    if (node) {
                        def restrictions = node.getNodeProperty(hudson.plugins.job_restrictions.nodes.JobRestrictionProperty.class)
                        if (restrictions == null) {
                            permissiveAgentRestrictions << [agent: computer.name, restriction: "None"]
                        }
                    }
                }
                
                if (permissiveAgentRestrictions.size() > 0 && severityValue('medium') >= minSeverityLevel) {
                    findings.add([
                        id: "AGENT-003",
                        severity: "medium",
                        area: "agents",
                        title: "No Agent Job Restrictions",
                        description: "Found ${permissiveAgentRestrictions.size()} agents without job restrictions.",
                        recommendation: "Configure job restrictions for agents to prevent unauthorized job execution.",
                        evidence: [
                            agents: permissiveAgentRestrictions
                        ]
                    ])
                }
            } catch (Exception ignored) {
                // Job restrictions plugin may not be configured correctly
            }
        }
        
        return findings
    }, LOGGER, [])
}

/**
 * Scans JVM security settings.
 * 
 * @param minSeverityLevel Minimum severity level to report
 * @return List of finding maps
 */
def scanJvmSecurity(int minSeverityLevel) {
    return ErrorHandler.withErrorHandling("scanning JVM security", {
        def findings = []
        
        // Check Java version
        def javaVersion = System.getProperty("java.version")
        def javaVendor = System.getProperty("java.vendor")
        
        if (javaVersion) {
            def versionParts = javaVersion.split("\\.")
            def majorVersion = versionParts[0] == "1" ? versionParts[1].toInteger() : versionParts[0].toInteger()
            
            if (majorVersion < 8 && severityValue('critical') >= minSeverityLevel) {
                findings.add([
                    id: "JVM-001",
                    severity: "critical",
                    area: "jvm",
                    title: "Obsolete Java Version",
                    description: "Jenkins is running on an obsolete Java version: ${javaVersion}",
                    recommendation: "Upgrade to Java 8 or higher for security updates and performance improvements.",
                    evidence: [
                        version: javaVersion,
                        vendor: javaVendor
                    ]
                ])
            } else if (majorVersion == 8 && severityValue('medium') >= minSeverityLevel) {
                findings.add([
                    id: "JVM-002",
                    severity: "medium",
                    area: "jvm",
                    title: "Aging Java Version",
                    description: "Jenkins is running on Java 8, which is approaching end-of-life for free updates.",
                    recommendation: "Consider upgrading to Java 11 LTS or 17 LTS for long-term support.",
                    evidence: [
                        version: javaVersion,
                        vendor: javaVendor
                    ]
                ])
            }
        }
        
        // Check for remote debugging
        def jvmArgs = ManagementFactory.getRuntimeMXBean().getInputArguments()
        def debugArgs = jvmArgs.findAll { it.contains("jdwp") || it.contains("debug") }
        
        if (debugArgs && severityValue('critical') >= minSeverityLevel) {
            findings.add([
                id: "JVM-003",
                severity: "critical",
                area: "jvm",
                title: "Remote Debugging Enabled",
                description: "Jenkins is running with remote debugging enabled: ${debugArgs}",
                recommendation: "Disable remote debugging in production environments.",
                evidence: [
                    debugArgs: debugArgs
                ]
            ])
        }
        
        // Check JVM security properties
        def securityManager = System.getSecurityManager() != null
        
        if (!securityManager && severityValue('low') >= minSeverityLevel) {
            findings.add([
                id: "JVM-004",
                severity: "low",
                area: "jvm",
                title: "No Security Manager",
                description: "Jenkins is running without a Java Security Manager.",
                recommendation: "Consider enabling the Java Security Manager with appropriate permissions for additional security.",
                evidence: [
                    securityManager: securityManager
                ]
            ])
        }
        
        return findings
    }, LOGGER, [])
}

/**
 * Scans Jenkins configuration for security issues.
 * 
 * @param jenkins The Jenkins instance
 * @param minSeverityLevel Minimum severity level to report
 * @return List of finding maps
 */
def scanJenkinsConfiguration(Jenkins jenkins, int minSeverityLevel) {
    return ErrorHandler.withErrorHandling("scanning Jenkins configuration", {
        def findings = []
        
        // Check CSRF protection
        def crsfEnabled = jenkins.crumbIssuer != null
        if (!crsfEnabled && severityValue('high') >= minSeverityLevel) {
            findings.add([
                id: "CONFIG-001",
                severity: "high",
                area: "configuration",
                title: "CSRF Protection Disabled",
                description: "Cross-Site Request Forgery (CSRF) protection is disabled.",
                recommendation: "Enable CSRF protection in global security settings.",
                evidence: [
                    crsfEnabled: crsfEnabled
                ]
            ])
        }
        
        // Check Jenkins URL configuration
        def jenkinsUrl = JenkinsLocationConfiguration.get()?.getUrl()
        if (!jenkinsUrl && severityValue('medium') >= minSeverityLevel) {
            findings.add([
                id: "CONFIG-002",
                severity: "medium",
                area: "configuration",
                title: "Jenkins URL Not Configured",
                description: "Jenkins URL is not configured, which may cause issues with notifications and agent connections.",
                recommendation: "Set the Jenkins URL in system configuration.",
                evidence: [
                    jenkinsUrl: jenkinsUrl
                ]
            ])
        } else if (jenkinsUrl?.startsWith("http://") && severityValue('medium') >= minSeverityLevel) {
            findings.add([
                id: "CONFIG-003",
                severity: "medium",
                area: "configuration",
                title: "Unencrypted Jenkins URL",
                description: "Jenkins URL is using unencrypted HTTP protocol: ${jenkinsUrl}",
                recommendation: "Configure Jenkins to use HTTPS for secure communications.",
                evidence: [
                    jenkinsUrl: jenkinsUrl
                ]
            ])
        }
        
        // Check Content Security Policy
        try {
            def contentSecurityPolicy = jenkins.getDescriptor(hudson.security.csrf.DefaultCrumbIssuer.class)?.excludeClientIPFromCrumb
            
            if (contentSecurityPolicy && severityValue('medium') >= minSeverityLevel) {
                findings.add([
                    id: "CONFIG-004",
                    severity: "medium",
                    area: "configuration",
                    title: "Weak CSRF Protection",
                    description: "CSRF protection is configured to exclude client IP, making it more vulnerable to certain attacks.",
                    recommendation: "Enable full CSRF protection by including client IP in the crumb.",
                    evidence: [
                        excludeClientIPFromCrumb: contentSecurityPolicy
                    ]
                ])
            }
        } catch (Exception ignored) {
            // CSRF configuration might not be available
        }
        
        // Check proxy configuration
        def proxy = jenkins.proxy
        if (proxy != null) {
            if (proxy.userName && proxy.password && severityValue('medium') >= minSeverityLevel) {
                findings.add([
                    id: "CONFIG-005",
                    severity: "medium",
                    area: "configuration",
                    title: "Proxy Authentication Found",
                    description: "Jenkins is configured to use a proxy with stored credentials.",
                    recommendation: "Ensure proxy credentials are securely stored and the proxy is trusted.",
                    evidence: [
                        proxyConfigured: true,
                        hasCredentials: true
                    ]
                ])
            }
        }
        
        // Check update site configuration
        def updateSites = jenkins.getUpdateCenter().getSites()
        def insecureUpdateSites = updateSites.findAll { !it.url.startsWith("https://") }
        
        if (insecureUpdateSites && severityValue('medium') >= minSeverityLevel) {
            findings.add([
                id: "CONFIG-006",
                severity: "medium",
                area: "configuration",
                title: "Insecure Update Sites",
                description: "Jenkins is configured with update sites using unencrypted HTTP.",
                recommendation: "Configure update sites to use HTTPS for secure downloads.",
                evidence: [
                    updateSites: insecureUpdateSites.collect { it.url }
                ]
            ])
        }
        
        return findings
    }, LOGGER, [])
}

/**
 * Generates a compliance report based on findings.
 * 
 * @param findings List of finding maps
 * @param standards List of compliance standards to check against
 * @return Map with compliance information
 */
def generateComplianceReport(List findings, List<String> standards) {
    def result = [:]
    
    if ('cis' in standards) {
        result.cis = generateCISComplianceReport(findings)
    }
    
    if ('owasp' in standards) {
        result.owasp = generateOWASPComplianceReport(findings)
    }
    
    if ('nist' in standards) {
        result.nist = generateNISTComplianceReport(findings)
    }
    
    return result
}

/**
 * Generates a CIS compliance report.
 * 
 * @param findings List of finding maps
 * @return Map with CIS compliance information
 */
def generateCISComplianceReport(List findings) {
    // Simplified CIS mapping - in a real implementation, this would map to actual CIS benchmarks
    def cisMapping = [
        "PLUGIN-001": "1.2 - Ensure security patches are applied",
        "PLUGIN-002": "1.2 - Ensure security patches are applied",
        "PLUGIN-003": "1.1 - Establish secure configurations",
        "CRED-001": "16.4 - Encrypt sensitive data in transit",
        "CRED-002": "16.5 - Protect sensitive data at rest",
        "CRED-003": "16.5 - Protect sensitive data at rest",
        "PERM-001": "4.8 - Separate accounts based on duties",
        "PERM-002": "4.3 - Ensure individuals requiring admin privileges use separate accounts",
        "PERM-003": "4.3 - Ensure individuals requiring admin privileges use separate accounts",
        "PERM-004": "4.13 - Monitor attempts to access deactivated accounts",
        "PERM-005": "4.1 - Maintain inventory of admin accounts",
        "SCRIPT-001": "5.1 - Establish secure configurations for infrastructure",
        "SCRIPT-002": "5.1 - Establish secure configurations for infrastructure",
        "SCRIPT-003": "18.9 - Sanitize code to protect against injection flaws",
        "SCRIPT-004": "18.9 - Sanitize code to protect against injection flaws",
        "AGENT-001": "9.2 - Ensure only approved ports are used",
        "AGENT-002": "9.2 - Ensure only approved ports are used",
        "AGENT-003": "9.1 - Associate ports with services",
        "JVM-001": "2.2 - Ensure software is supported by vendor",
        "JVM-002": "2.2 - Ensure software is supported by vendor",
        "JVM-003": "9.2 - Ensure only approved ports are used",
        "JVM-004": "5.1 - Establish secure configurations for infrastructure",
        "CONFIG-001": "18.5 - Use security features built into systems",
        "CONFIG-002": "18.5 - Use security features built into systems",
        "CONFIG-003": "14.4 - Encrypt data in transit",
        "CONFIG-004": "18.5 - Use security features built into systems",
        "CONFIG-005": "16.5 - Protect sensitive data at rest",
        "CONFIG-006": "14.4 - Encrypt data in transit"
    ]
    
    // Count findings by CIS control
    def controlFindings = [:]
    
    findings.each { finding ->
        def control = cisMapping[finding.id]
        if (control) {
            if (!controlFindings[control]) {
                controlFindings[control] = []
            }
            controlFindings[control] << finding
        }
    }
    
    // Calculate compliance percentage
    def totalControls = cisMapping.values().unique().size()
    def nonCompliantControls = controlFindings.keySet().size()
    def compliancePercentage = totalControls > 0 ? ((totalControls - nonCompliantControls) / totalControls) * 100 : 100
    
    return [
        framework: "CIS Controls",
        version: "8.0",
        compliancePercentage: compliancePercentage,
        compliantControls: totalControls - nonCompliantControls,
        totalControls: totalControls,
        nonCompliantControls: controlFindings.collect { control, controlFindings ->
            [
                control: control,
                findings: controlFindings.collect { it.id }
            ]
        }
    ]
}

/**
 * Generates an OWASP compliance report.
 * 
 * @param findings List of finding maps
 * @return Map with OWASP compliance information
 */
def generateOWASPComplianceReport(List findings) {
    // Simplified OWASP Top 10 mapping
    def owaspMapping = [
        "PLUGIN-001": "A6:2017-Security Misconfiguration",
        "PLUGIN-002": "A9:2017-Using Components with Known Vulnerabilities",
        "PLUGIN-003": "A6:2017-Security Misconfiguration",
        "CRED-001": "A6:2017-Security Misconfiguration",
        "CRED-002": "A3:2017-Sensitive Data Exposure",
        "CRED-003": "A3:2017-Sensitive Data Exposure",
        "PERM-001": "A5:2017-Broken Access Control",
        "PERM-002": "A5:2017-Broken Access Control",
        "PERM-003": "A5:2017-Broken Access Control",
        "PERM-004": "A2:2017-Broken Authentication",
        "PERM-005": "A5:2017-Broken Access Control",
        "SCRIPT-001": "A8:2017-Insecure Deserialization",
        "SCRIPT-002": "A8:2017-Insecure Deserialization",
        "SCRIPT-003": "A1:2017-Injection",
        "SCRIPT-004": "A1:2017-Injection",
        "AGENT-001": "A6:2017-Security Misconfiguration",
        "AGENT-002": "A6:2017-Security Misconfiguration",
        "AGENT-003": "A5:2017-Broken Access Control",
        "JVM-001": "A9:2017-Using Components with Known Vulnerabilities",
        "JVM-002": "A9:2017-Using Components with Known Vulnerabilities",
        "JVM-003": "A6:2017-Security Misconfiguration",
        "JVM-004": "A6:2017-Security Misconfiguration",
        "CONFIG-001": "A5:2017-Broken Access Control",
        "CONFIG-002": "A6:2017-Security Misconfiguration",
        "CONFIG-003": "A3:2017-Sensitive Data Exposure",
        "CONFIG-004": "A5:2017-Broken Access Control",
        "CONFIG-005": "A3:2017-Sensitive Data Exposure",
        "CONFIG-006": "A3:2017-Sensitive Data Exposure"
    ]
    
    // Count findings by OWASP category
    def categoryFindings = [:]
    
    findings.each { finding ->
        def category = owaspMapping[finding.id]
        if (category) {
            if (!categoryFindings[category]) {
                categoryFindings[category] = []
            }
            categoryFindings[category] << finding
        }
    }
    
    // Total OWASP Top 10 categories
    def owaspCategories = [
        "A1:2017-Injection",
        "A2:2017-Broken Authentication",
        "A3:2017-Sensitive Data Exposure",
        "A4:2017-XML External Entities (XXE)",
        "A5:2017-Broken Access Control",
        "A6:2017-Security Misconfiguration",
        "A7:2017-Cross-Site Scripting (XSS)",
        "A8:2017-Insecure Deserialization",
        "A9:2017-Using Components with Known Vulnerabilities",
        "A10:2017-Insufficient Logging & Monitoring"
    ]
    
    // Calculate compliance percentage
    def totalCategories = owaspCategories.size()
    def nonCompliantCategories = categoryFindings.keySet().size()
    def compliancePercentage = ((totalCategories - nonCompliantCategories) / totalCategories) * 100
    
    return [
        framework: "OWASP Top 10",
        version: "2017",
        compliancePercentage: compliancePercentage,
        compliantCategories: totalCategories - nonCompliantCategories,
        totalCategories: totalCategories,
        nonCompliantCategories: categoryFindings.collect { category, catFindings ->
            [
                category: category,
                findingsCount: catFindings.size(),
                findings: catFindings.collect { it.id }
            ]
        }
    ]
}

/**
 * Generates a NIST compliance report.
 * 
 * @param findings List of finding maps
 * @return Map with NIST compliance information
 */
def generateNISTComplianceReport(List findings) {
    // Simplified NIST mapping
    def nistMapping = [
        "PLUGIN-001": "SI-2",
        "PLUGIN-002": "SI-2",
        "PLUGIN-003": "SI-3",
        "CRED-001": "IA-5",
        "CRED-002": "AC-3",
        "CRED-003": "SC-28",
        "PERM-001": "AC-2",
        "PERM-002": "AC-6",
        "PERM-003": "AC-6",
        "PERM-004": "IA-5",
        "PERM-005": "AC-6",
        "SCRIPT-001": "SI-3",
        "SCRIPT-002": "SI-3",
        "SCRIPT-003": "SA-11",
        "SCRIPT-004": "SA-11",
        "AGENT-001": "CM-6",
        "AGENT-002": "CM-6",
        "AGENT-003": "AC-3",
        "JVM-001": "SI-2",
        "JVM-002": "SI-2",
        "JVM-003": "CM-7",
        "JVM-004": "CM-6",
        "CONFIG-001": "SC-23",
        "CONFIG-002": "CM-6",
        "CONFIG-003": "SC-8",
        "CONFIG-004": "SC-23",
        "CONFIG-005": "SC-28",
        "CONFIG-006": "SC-8"
    ]
    
    // Count findings by NIST control
    def controlFindings = [:]
    
    findings.each { finding ->
        def control = nistMapping[finding.id]
        if (control) {
            if (!controlFindings[control]) {
                controlFindings[control] = []
            }
            controlFindings[control] << finding
        }
    }
    
    // Calculate compliance percentage (simplified)
    def totalControls = nistMapping.values().unique().size()
    def nonCompliantControls = controlFindings.keySet().size()
    def compliancePercentage = ((totalControls - nonCompliantControls) / totalControls) * 100
    
    return [
        framework: "NIST SP 800-53",
        version: "Rev. 5",
        compliancePercentage: compliancePercentage,
        compliantControls: totalControls - nonCompliantControls,
        totalControls: totalControls,
        nonCompliantControls: controlFindings.collect { control, ctrlFindings ->
            [
                control: control,
                findingsCount: ctrlFindings.size(),
                findings: ctrlFindings.collect { it.id }
            ]
        }
    ]
}

/**
 * Formats the scan results into a human-readable string.
 * 
 * @param scanResults The scan results map
 * @param includeDetailed Whether to include detailed information
 * @return Formatted string
 */
def formatScanResults(Map scanResults, boolean includeDetailed) {
    def builder = new StringBuilder()
    
    // Format header
    builder.append("=".multiply(80))
    builder.append("\n")
    builder.append("JENKINS SECURITY VULNERABILITY SCAN RESULTS\n")
    builder.append("=".multiply(80))
    builder.append("\n\n")
    
    // Format summary
    def summary = scanResults.summary
    builder.append("SUMMARY:\n")
    builder.append("  Scan Time: ${summary.scanTime}\n")
    builder.append("  Duration: ${formatDuration(summary.duration)}\n")
    builder.append("  Jenkins Version: ${summary.jenkinsVersion}\n")
    builder.append("  Total Findings: ${summary.totalFindings}\n")
    builder.append("  Scanned Areas: ${summary.scannedAreas.join(', ')}\n\n")
    
    builder.append("SEVERITY BREAKDOWN:\n")
    builder.append("  Critical: ${summary.severityCounts.critical}\n")
    builder.append("  High: ${summary.severityCounts.high}\n")
    builder.append("  Medium: ${summary.severityCounts.medium}\n")
    builder.append("  Low: ${summary.severityCounts.low}\n")
    builder.append("  Info: ${summary.severityCounts.info}\n\n")
    
    // Format findings
    if (scanResults.findings.isEmpty()) {
        builder.append("No security findings to report.\n\n")
    } else {
        builder.append("FINDINGS:\n")
        
        // Group by severity for better readability
        def severities = ['critical', 'high', 'medium', 'low', 'info']
        severities.each { severity ->
            def severityFindings = scanResults.findings.findAll { it.severity == severity }
            if (severityFindings) {
                builder.append("\n${severity.toUpperCase()} SEVERITY (${severityFindings.size()}):\n")
                
                severityFindings.each { finding ->
                    builder.append("-".multiply(80))
                    builder.append("\n")
                    builder.append("[${finding.id}] ${finding.title}\n")
                    builder.append("  Area: ${finding.area}\n")
                    builder.append("  Description: ${finding.description}\n")
                    builder.append("  Recommendation: ${finding.recommendation}\n")
                    
                    if (includeDetailed && finding.evidence) {
                        builder.append("  Evidence:\n")
                        serializeEvidence(finding.evidence, builder, "    ")
                    }
                    
                    builder.append("\n")
                }
            }
        }
    }
    
    // Format compliance results if available
    if (scanResults.compliance) {
        builder.append("=".multiply(80))
        builder.append("\nCOMPLIANCE REPORTS\n")
        builder.append("=".multiply(80))
        builder.append("\n\n")
        
        scanResults.compliance.each { standard, report ->
            builder.append("${report.framework} (${report.version}):\n")
            builder.append("  Compliance: ${String.format("%.1f%%", report.compliancePercentage)}\n")
            builder.append("  Compliant Controls: ${report.compliantControls} of ${report.totalControls}\n")
            
            if (report.nonCompliantControls) {
                builder.append("\n  Non-Compliant Controls:\n")
                report.nonCompliantControls.each { controlIssue ->
                    builder.append("    - ${controlIssue.control}\n")
                }
            }
            
            builder.append("\n")
        }
    }
    
    return builder.toString()
}

/**
 * Recursively serializes evidence data.
 * 
 * @param evidence The evidence data
 * @param builder The string builder to append to
 * @param indent The indentation to use
 */
def serializeEvidence(evidence, StringBuilder builder, String indent) {
    if (evidence instanceof Map) {
        evidence.each { key, value ->
            if (value instanceof Map || value instanceof List) {
                builder.append("${indent}${key}:\n")
                serializeEvidence(value, builder, indent + "  ")
            } else {
                builder.append("${indent}${key}: ${value}\n")
            }
        }
    } else if (evidence instanceof List) {
        evidence.eachWithIndex { item, index ->
            if (item instanceof Map || item instanceof List) {
                builder.append("${indent}${index}:\n")
                serializeEvidence(item, builder, indent + "  ")
            } else {
                builder.append("${indent}${index}: ${item}\n")
            }
        }
    } else {
        builder.append("${indent}${evidence}\n")
    }
}

/**
 * Gets the numeric value of a severity level.
 * 
 * @param severity The severity level
 * @return Numeric value
 */
def severityValue(String severity) {
    def severityLevels = ['critical': 5, 'high': 4, 'medium': 3, 'low': 2, 'info': 1]
    return severityLevels[severity.toLowerCase()] ?: 0
}

/**
 * Compares two version strings.
 * 
 * @param version1 The first version string
 * @param version2 The second version string
 * @return true if version1 is less than version2
 */
def isVersionLessThan(String version1, String version2) {
    def v1Parts = version1.tokenize('.')
    def v2Parts = version2.tokenize('.')
    
    for (int i = 0; i < Math.min(v1Parts.size(), v2Parts.size()); i++) {
        def v1Part = v1Parts[i].toInteger()
        def v2Part = v2Parts[i].toInteger()
        
        if (v1Part < v2Part) {
            return true
        } else if (v1Part > v2Part) {
            return false
        }
    }
    
    return v1Parts.size() < v2Parts.size()
}

/**
 * Formats a duration in milliseconds to a human-readable string.
 * 
 * @param durationMs Duration in milliseconds
 * @return Formatted duration string
 */
def formatDuration(long durationMs) {
    def seconds = durationMs / 1000
    def minutes = (int)(seconds / 60)
    def hours = (int)(minutes / 60)
    
    minutes = minutes % 60
    seconds = seconds % 60
    
    if (hours > 0) {
        return String.format("%dh %02dm %02ds", hours, minutes, (int)seconds)
    } else if (minutes > 0) {
        return String.format("%dm %02ds", minutes, (int)seconds)
    } else {
        return String.format("%.1fs", seconds)
    }
}