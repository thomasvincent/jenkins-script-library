/*
 * MIT License
 *
 * Copyright (c) 2023-2025 Thomas Vincent
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package com.github.thomasvincent.jenkinsscripts.scripts

import spock.lang.Specification
import spock.lang.Unroll
import jenkins.model.Jenkins
import hudson.PluginWrapper
import hudson.PluginManager
import hudson.model.UpdateCenter
import hudson.model.UpdateSite
import hudson.security.AuthorizationStrategy
import hudson.security.ACL
import hudson.model.User
import hudson.security.Permission
import hudson.security.ACL.DangerouslyUnrestrictedACL
import jenkins.security.s2m.AdminWhitelistRule
import jenkins.security.s2m.MasterKillSwitchConfiguration
import org.jenkinsci.plugins.workflow.job.WorkflowJob
import jenkins.model.JenkinsLocationConfiguration
import org.acegisecurity.Authentication

/**
 * Unit tests for SecurityVulnerabilityScan script functions.
 * 
 * This tests the individual functions defined within the SecurityVulnerabilityScan script.
 * Testing is done by extracting and binding the functions to this test class.
 */
class SecurityVulnerabilityScanTest extends Specification {

    def jenkins = Mock(Jenkins)
    def pluginManager = Mock(PluginManager)
    def updateCenter = Mock(UpdateCenter)
    def locationConfig = Mock(JenkinsLocationConfiguration)
    def adminWhitelistRule = Mock(AdminWhitelistRule)
    def masterKillSwitchConfig = Mock(MasterKillSwitchConfiguration)
    def authStrategy = Mock(AuthorizationStrategy)
    def acl = Mock(ACL)
    def updateSite = Mock(UpdateSite)
    
    // Plugins for testing
    def plugins = []
    
    // Functions to test - these would be extracted from the script
    def scanPlugins
    def scanJenkinsConfiguration
    def isVersionLessThan
    def formatScanResults
    def severityValue
    
    def setup() {
        // Setup plugin manager
        def plugin1 = Mock(PluginWrapper)
        plugin1.getShortName() >> "credentials"
        plugin1.getDisplayName() >> "Credentials Plugin"
        plugin1.getVersion() >> "2.3.0"
        plugin1.hasUpdate() >> true
        plugin1.isActive() >> true
        plugin1.isEnabled() >> true
        plugin1.getUpdateInfo() >> Mock(UpdateCenter.Plugin) { getVersion() >> "2.5.0" }
        
        def plugin2 = Mock(PluginWrapper)
        plugin2.getShortName() >> "git"
        plugin2.getDisplayName() >> "Git Plugin"
        plugin2.getVersion() >> "3.9.0"
        plugin2.hasUpdate() >> false
        plugin2.isActive() >> true
        plugin2.isEnabled() >> true
        
        plugins = [plugin1, plugin2]
        pluginManager.plugins >> plugins
        
        // Setup update center
        updateCenter.getSites() >> [updateSite]
        updateSite.url >> "https://updates.jenkins.io/update-center.json"
        
        // Setup Jenkins
        jenkins.pluginManager >> pluginManager
        jenkins.getUpdateCenter() >> updateCenter
        jenkins.getVersion() >> "2.303.3"
        jenkins.isUseSecurity() >> true
        jenkins.ADMINISTER >> Permission.READ
        jenkins.ANONYMOUS >> Mock(Authentication)
        
        // Setup authorization strategy
        jenkins.getAuthorizationStrategy() >> authStrategy
        authStrategy.getACL(jenkins) >> acl
        acl.hasPermission(_ as Authentication, Permission.READ) >> false
        
        // Setup master-agent security
        jenkins.getExtensionList(MasterKillSwitchConfiguration.class) >> [masterKillSwitchConfig]
        jenkins.getExtensionList(AdminWhitelistRule.class) >> [adminWhitelistRule]
        masterKillSwitchConfig.getMasterKillSwitch() >> false
        adminWhitelistRule.getMasterKillSwitch() >> false
        
        // Setup location config
        JenkinsLocationConfiguration.metaClass.static.get = { -> locationConfig }
        locationConfig.getUrl() >> "https://jenkins.example.com/"
        
        // Implement test functions
        scanPlugins = { Jenkins jenkins, int minSeverityLevel ->
            def findings = []
            def plugins = jenkins.pluginManager.plugins
            
            // Check for outdated plugins
            plugins.each { plugin ->
                if (plugin.hasUpdate()) {
                    def severity = 'medium'
                    if (plugin.isActive() && plugin.isEnabled() && plugin.getShortName() in ['credentials', 'ssh-credentials', 'script-security', 'matrix-auth', 'role-strategy']) {
                        severity = 'high'
                    }
                    
                    if (severityValue(severity) >= minSeverityLevel) {
                        findings.add([
                            id: "PLUGIN-001",
                            severity: severity,
                            area: "plugins",
                            title: "Outdated Plugin: ${plugin.getDisplayName()}",
                            description: "Plugin ${plugin.getDisplayName()} (${plugin.getShortName()}) version ${plugin.getVersion()} has an update available.",
                            recommendation: "Update the plugin to the latest version to address security vulnerabilities.",
                            evidence: [
                                currentVersion: plugin.getVersion(),
                                latestVersion: plugin.getUpdateInfo()?.version ?: "unknown",
                                plugin: plugin.getShortName()
                            ]
                        ])
                    }
                }
            }
            
            return findings
        }
        
        scanJenkinsConfiguration = { Jenkins jenkins, int minSeverityLevel ->
            def findings = []
            
            // Check CSRF protection
            def crsfEnabled = jenkins.crumbIssuer != null
            if (!crsfEnabled && severityValue('high') >= minSeverityLevel) {
                findings.add([
                    id: "CONFIG-001",
                    severity: "high",
                    area: "configuration",
                    title: "CSRF Protection Disabled",
                    description: "Cross-Site Request Forgery (CSRF) protection is disabled.",
                    recommendation: "Enable CSRF protection in global security settings.",
                    evidence: [
                        crsfEnabled: crsfEnabled
                    ]
                ])
            }
            
            // Check Jenkins URL configuration
            def jenkinsUrl = JenkinsLocationConfiguration.get()?.getUrl()
            if (!jenkinsUrl && severityValue('medium') >= minSeverityLevel) {
                findings.add([
                    id: "CONFIG-002",
                    severity: "medium",
                    area: "configuration",
                    title: "Jenkins URL Not Configured",
                    description: "Jenkins URL is not configured, which may cause issues with notifications and agent connections.",
                    recommendation: "Set the Jenkins URL in system configuration.",
                    evidence: [
                        jenkinsUrl: jenkinsUrl
                    ]
                ])
            } else if (jenkinsUrl?.startsWith("http://") && severityValue('medium') >= minSeverityLevel) {
                findings.add([
                    id: "CONFIG-003",
                    severity: "medium",
                    area: "configuration",
                    title: "Unencrypted Jenkins URL",
                    description: "Jenkins URL is using unencrypted HTTP protocol: ${jenkinsUrl}",
                    recommendation: "Configure Jenkins to use HTTPS for secure communications.",
                    evidence: [
                        jenkinsUrl: jenkinsUrl
                    ]
                ])
            }
            
            return findings
        }
        
        isVersionLessThan = { String version1, String version2 ->
            def v1Parts = version1.tokenize('.')
            def v2Parts = version2.tokenize('.')
            
            for (int i = 0; i < Math.min(v1Parts.size(), v2Parts.size()); i++) {
                def v1Part = v1Parts[i].toInteger()
                def v2Part = v2Parts[i].toInteger()
                
                if (v1Part < v2Part) {
                    return true
                } else if (v1Part > v2Part) {
                    return false
                }
            }
            
            return v1Parts.size() < v2Parts.size()
        }
        
        formatScanResults = { Map scanResults, boolean includeDetailed ->
            def builder = new StringBuilder()
            
            // Simple version for testing
            builder.append("JENKINS SECURITY VULNERABILITY SCAN RESULTS\n")
            
            def summary = scanResults.summary
            builder.append("  Total Findings: ${summary.totalFindings}\n")
            
            if (scanResults.findings.isEmpty()) {
                builder.append("No security findings to report.\n")
            } else {
                builder.append("FINDINGS:\n")
                scanResults.findings.each { finding ->
                    builder.append("  [${finding.id}] ${finding.title}\n")
                    builder.append("    Area: ${finding.area}\n")
                    builder.append("    Severity: ${finding.severity}\n")
                }
            }
            
            return builder.toString()
        }
        
        severityValue = { String severity ->
            def severityLevels = ['critical': 5, 'high': 4, 'medium': 3, 'low': 2, 'info': 1]
            return severityLevels[severity.toLowerCase()] ?: 0
        }
    }
    
    def "scanPlugins should detect outdated plugins"() {
        when:
        def findings = scanPlugins(jenkins, 1) // min severity: info
        
        then:
        findings.size() == 1
        findings[0].id == "PLUGIN-001"
        findings[0].severity == "high" // credentials plugin is high severity
        findings[0].area == "plugins"
    }
    
    def "scanPlugins should filter by minimum severity"() {
        when:
        def findings = scanPlugins(jenkins, 5) // min severity: critical
        
        then:
        findings.size() == 0 // no critical findings
    }
    
    def "scanJenkinsConfiguration should detect CSRF issues"() {
        given:
        jenkins.crumbIssuer >> null // CSRF disabled
        
        when:
        def findings = scanJenkinsConfiguration(jenkins, 1) // min severity: info
        
        then:
        findings.find { it.id == "CONFIG-001" } != null
    }
    
    def "scanJenkinsConfiguration should detect HTTP URL issue"() {
        given:
        locationConfig.getUrl() >> "http://jenkins.example.com/" // Unencrypted URL
        
        when:
        def findings = scanJenkinsConfiguration(jenkins, 1) // min severity: info
        
        then:
        findings.find { it.id == "CONFIG-003" } != null
    }
    
    @Unroll
    def "isVersionLessThan should correctly compare #v1 and #v2"() {
        expect:
        isVersionLessThan(v1, v2) == expected
        
        where:
        v1      | v2      | expected
        "1.0.0" | "1.0.1" | true
        "1.0.0" | "1.1.0" | true
        "2.0.0" | "1.0.0" | false
        "1.0"   | "1.0.0" | true
        "1.0.0" | "1.0"   | false
    }
    
    def "formatScanResults should format results properly"() {
        given:
        def scanResults = [
            summary: [
                totalFindings: 2,
                jenkinsVersion: "2.303.3"
            ],
            findings: [
                [
                    id: "TEST-001", 
                    title: "Test Finding 1",
                    area: "test",
                    severity: "high"
                ],
                [
                    id: "TEST-002", 
                    title: "Test Finding 2",
                    area: "test",
                    severity: "medium"
                ]
            ]
        ]
        
        when:
        def result = formatScanResults(scanResults, false)
        
        then:
        result.contains("JENKINS SECURITY VULNERABILITY SCAN RESULTS")
        result.contains("Total Findings: 2")
        result.contains("[TEST-001] Test Finding 1")
        result.contains("[TEST-002] Test Finding 2")
    }
    
    @Unroll
    def "severityValue should return correct value for #severity"() {
        expect:
        severityValue(severity) == value
        
        where:
        severity    | value
        "critical"  | 5
        "high"      | 4
        "medium"    | 3
        "low"       | 2
        "info"      | 1
        "unknown"   | 0
    }
}